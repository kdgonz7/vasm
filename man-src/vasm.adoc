= vasm(1)
VOLT Foundation
v1.0.0
:doctype: manpage
:manmanual: VASM
:mansource: VASM
:manname-title: vasm

== Name

vasm - A compiler for the OpenLUD, NexFUSE, SolarisVM, and JADE VMs.

== Synopsis

vasm [FILE ...] [OPTIONS ...]

== Description

A standard compiler for LR Assembly, a weakly typed assembler language designed
to be compatible with multiple VM environments.

== Options

*-h --help*::
  Shows this message
*--format, -f FORMAT*::
Configures the format used in the binary. The format defines the instruction set used in the
compilation process. Binary sizes and bits are handled in this option. For example, selecting
the **openlud** option will automatically create an 8-bit vendor instead of truncating
a 32-bit one. See **VENDORS** for more information.

*-O<N>*::
Defines the optimization level for the compiler. This option has an effect on the output binary.
  * *O0*
  ** No optimizations.
  * *O1*
  ** Adds peephole optimizations such as dead code elimination.
  * *O2*
  ** Forcibly quitting after an empty procedure, and optimizing code as its written instead of after its wrote.

== Vendors

A "vendor" is defined as information to help generate binaries based on documented instructions sets. Instead of mapping each instruction to a number, vasm supports generation of binaries through hand-implemented functions which are children of instructions. Using the VASM zig API, the OpenLUD vendor is created using the following method:

[source,zig]
-----
pub fn vendor(vend: *codegen.Vendor(i8)) !void {
    vend.nul_after_sequence = true;
    vend.nul_byte = 0;

    try vend.createAndImplementInstruction(i8, "echo", &echoInstruction);
    try vend.createAndImplementInstruction(i8, "mov", &moveInstruction);
    try vend.createAndImplementInstruction(i8, "each", &eachInstruction);
    try vend.createAndImplementInstruction(i8, "init", &initInstruction);
    // ...
}
-----

The above example uses `createAndImplementInstruction` to implement a couple instructions that are specific to the OpenLUD format. These are optional as they are a part of the compilation process and not the language itself. Vendors are just a separate implementation that defines a streamlined process of compiling and verifying binaries.

Vendors then take input source and turn it into a **PROCEDURE MAP** that can then be operated on separately. Procedure maps are key-value pairs that represent the procedure hierarchy of a program. Procedures can be tagged by size (example a *5-byte procedure*) and in that stage is where peephole optimizations can take place. The peephole optimizer (defined in _peephole.zig_) is not aware of the original source code and only aware of the generated binary, however, using information given to the optimizer prior, is able to free up and remove procedures that go unused.

In hindsight, this doesn't have much benefit aside from memory consumption when procedure folding is enabled, however, using _NexFUSE-like Procedures_ (where each procedure label is engraved in the resulting binary) yields higher results.

== Information

ifdef::revnumber[This document's version is {revnumber}.]
