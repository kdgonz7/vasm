//! LR Assembly codegen
//!
//! Lexing => Parsing => Stylist => Syntax Tree Generation => Linting => Codegen => Templating => Export
//! 1         2          3          4                         5          6          7             8
//!
//! Code generation is the 6th step in the simple LR assembly pipeline. This step
//! is meant to generate procedure maps for binaries. Code generation makes it easy to
//! define new systems by using the `Vendor` class. The Vendor class holds a hashmap from
//! instructions to raw instruction functions, and the vendor can generate bytes that are held
//! in the struct itself.
//!
//! This step does NOT generate usable binaries and therefore can not be written directly to files. The
//! Code generation stage is meant to generate actual byte code depending on the Vendor struct and the given
//! instruction set.
//!

const std = @import("std");
const peephole = @import("peephole.zig");
const instruction_result = @import("instruction_result.zig");
const lex = @import("lexer.zig");
const parse = @import("parser.zig");
const token_stream = @import("token_stream.zig");

const Lexer = lex.Lexer;
const LexerArea = lex.LexerArea;

const Parser = parse.Parser;

const Node = parse.Node;
const NodeTag = parse.NodeTag;

const Value = parse.Value;
const ValueTag = parse.ValueTag;

const Root = parse.Root;
const Procedure = parse.Procedure;

const InstructionResult = instruction_result.InstructionResult;

const Span = token_stream.Span;

pub const InstructionError = error{
    OutOfMemory,
    InstructionExpectsDifferentValue,
    InstructionDoesntExist,
    TestExpectedEqual,
    InstructionError,
    ParamsToInstructionAreWrong,
};

pub const CodegenError = error{
    /// an invalid root expression was encountered
    InvalidExpressionRoot,
    RegisterNumberTooLarge,
};

pub const TypeTag = enum {
    single_type,
};

pub const Type = union(TypeTag) {
    single_type: ValueTag,

    pub fn init(t: ValueTag) Type {
        return Type{
            .single_type = t,
        };
    }

    pub fn getParamType(self: *const Type) TypeTag {
        return switch (self.*) {
            .single_type => TypeTag.single_type,
        };
    }

    pub fn asSingleType(self: *const Type) ValueTag {
        switch (self.*) {
            .single_type => |t| return t,
        }
    }
};

/// An annotation for an instruction. Specifies the value types that the instruction can accept.
///
/// TODO
pub const Annotation = struct {
    type_list: std.ArrayList(Type),

    pub fn init(parent_allocator: std.mem.Allocator, t_list: []const Type) Annotation {
        var ann = Annotation{
            .type_list = std.ArrayList(Type).init(parent_allocator),
        };

        ann.type_list.appendSlice(t_list) catch unreachable;

        return ann;
    }
};

/// Instruction information for compiler debugging. Not meant for actual use in runtimes, etc.
pub fn Instruction(comptime format: type) type {
    return struct {
        /// The instruction's internal name (used for debugging)
        name: []const u8,

        /// The function ran from the instruction
        function: *const fn (*Generator(format), *Vendor(format), []Value) InstructionError!InstructionResult,

        annotation: ?Annotation = null,

        pub fn init(name: []const u8, function: *const fn (*Generator(format), *Vendor(format), []Value) InstructionError!InstructionResult) Instruction(format) {
            return Instruction(format){
                .name = name,
                .function = function,
            };
        }
    };
}

/// The generator object holds the binary generated by an instruction.
///
/// Example:
///
/// ```
///
/// fn (generator: *Generator(i32), vendor: *Vendor(i32), args: []Value) !void {
///     // generator => the binary generator
///     // vendor    => The codegen vendor. Contains environment-specific information
///     // args      => arguments passed into this instruction.
///     try generator.append(0xAB);
///     try generator.append(args[0].number.getNumber());
/// }
/// ```
pub fn Generator(comptime T: type) type {
    return struct {
        binary: std.ArrayList(T),
        parent_allocator: std.mem.Allocator,

        pub fn init(parent_allocator: std.mem.Allocator) Generator(T) {
            return Generator(T){
                .parent_allocator = parent_allocator,
                .binary = std.ArrayList(T).init(parent_allocator),
            };
        }

        pub fn append(self: *Generator(T), byte: T) !void {
            try self.binary.append(byte);
        }
    };
}

/// Best to allocate with an arena.
///
/// A VENDOR for text -> instructions and macros. It is safest to run using an arena allocator, and parent to the desired
/// allocator. Reason being memory will become more complex and hard to manage as the data structure grows. So it's
/// best to just use an arena and save the trouble.
///
pub fn Vendor(comptime format_type: type) type {
    return struct {
        const Self = @This();

        /// The procedure map holds `name` -> `binary`. Essentially the .sections section in the file
        procedure_map: std.StringHashMap(std.ArrayList(format_type)),

        /// The list of strings to instructions. These
        /// are ran with their respective parameters.
        instruction_set: std.StringHashMap(Instruction(format_type)),

        /// The dead code eliminator
        peephole_optimizer: peephole.PeepholeOptimizer(format_type),

        /// the parent allocator.
        parent_allocator: std.mem.Allocator,

        /// Place a NULL byte at the end of an instruction binary?
        nul_after_sequence: bool = false,
        nul_byte: format_type = 0,

        /// Should the END byte be added at the end of a procedure?
        procedure_add_end: bool = false,
        end_byte: format_type = 0,

        /// A list of instruction results ran from each instruction.
        results: std.ArrayList(InstructionResult),

        /// The last result that caused an error
        erroneous_result: InstructionResult = undefined,

        /// The last token that caused an error
        erroneous_token: Value = undefined,

        /// The last span that caused an error
        erroneous_span: Span = undefined,

        /// The last expected value type
        erroneous_expected: ?ValueTag = null,
        erroneous_got: ?ValueTag = null,

        /// A map of annotations.
        annotations: std.StringHashMap(Annotation) = undefined,

        pub fn init(parent_allocator: std.mem.Allocator) Self {
            return Self{
                .parent_allocator = parent_allocator,
                .procedure_map = std.StringHashMap(std.ArrayList(format_type)).init(parent_allocator),
                .instruction_set = std.StringHashMap(Instruction(format_type)).init(parent_allocator),
                .peephole_optimizer = peephole.PeepholeOptimizer(format_type).init(parent_allocator),
                .annotations = std.StringHashMap(Annotation).init(parent_allocator),
                .results = std.ArrayList(InstructionResult).init(parent_allocator),
            };
        }

        pub fn deinit(self: *Self) void {
            self.procedure_map.deinit();
            self.instruction_set.deinit();
        }

        /// Puts `name` to `instruction`
        pub fn implementInstruction(self: *Self, name: []const u8, instruction: *Instruction(format_type)) !void {
            try self.instruction_set.put(name, instruction.*);
        }

        pub fn createAndImplementInstruction(
            self: *Self,
            comptime size: type,
            name: []const u8,
            function: *const fn (
                generator: *Generator(size),
                vendor: *Vendor(size),
                args: []Value,
            ) InstructionError!InstructionResult,
        ) !void {
            try self.instruction_set.put(name, Instruction(size){
                .function = function,
                .name = name,
            });
        }

        pub fn createAndImplementInstructionWithAnnotation(
            self: *Self,
            comptime size: type,
            name: []const u8,
            function: *const fn (
                generator: *Generator(size),
                vendor: *Vendor(size),
                args: []Value,
            ) InstructionError!InstructionResult,
            type_list: []const Type,
        ) !void {
            try self.instruction_set.put(name, Instruction(size){
                .function = function,
                .name = name,
            });

            try self.registerAnnotation(name, type_list);
        }

        pub fn registerAnnotation(self: *Self, for_function: []const u8, type_list: []const Type) !void {
            try self.annotations.put(for_function, Annotation.init(
                self.parent_allocator,
                type_list,
            ));
        }

        /// Populates the vendor's procedure map with instructions by running their
        /// respective functions.
        pub fn generateBinary(self: *Self, node: Node) !void {
            switch (node) {
                .root => |*root_node| {
                    for (root_node.children.items) |*child| {
                        switch (child.*) {
                            .procedure => |*proc| {
                                try self.generateBinaryProcedure(proc);
                            },

                            // ignore macros, that's for the macro stage
                            .macro => |_| {},

                            else => {
                                return error.InvalidExpressionRoot;
                            },
                        }
                    }
                },

                else => {},
            }
        }

        /// Generates the memory layout of a procedure. Iterates the instructions and runs them
        /// one by one in order, populating their space in the procedure map in the process.
        ///
        /// This function will also take into account instructions that are a part of the
        /// procedure map, and also run those accordingly. User-defined procedures have higher
        /// precedent over instruction set procedures.
        ///
        pub fn generateBinaryProcedure(self: *Self, child: *Procedure) !void {
            const procedure_name = child.header;
            var generator = Generator(format_type).init(self.parent_allocator);

            for (child.children.items[0..]) |call| {
                switch (call) {
                    // if its an instruction call
                    .instruction_call => |ins| {
                        if (self.procedure_map.get(ins.name.identifier_string)) |proc| {
                            for (proc.items) |byt| {
                                try generator.append(byt);
                            }

                            // that instruction has been expanded once and is in use
                            try self.peephole_optimizer.remember(ins.name.identifier_string);
                        } else {

                            // built in instruction
                            if (self.instruction_set.get(ins.name.identifier_string)) |map_item| {
                                for (ins.parameters.items) |it| {
                                    if (it.getType() == .register and it.toRegister().getRegisterNumber() > std.math.maxInt(format_type)) {
                                        self.erroneous_token = it;
                                        return error.RegisterNumberTooLarge;
                                    }
                                }

                                if (self.annotations.get(ins.name.identifier_string)) |annotation| {
                                    // conditions for annotations
                                    // the param list and annotation list must be the same len
                                    // they must have the same types
                                    // annotation list and check it against the param list
                                    // if its a multiple type, check for either type.

                                    if (ins.parameters.items.len != annotation.type_list.items.len) {
                                        self.erroneous_span = ins.name.span;
                                        return error.ParamsToInstructionAreWrong;
                                    }

                                    for (0..ins.parameters.items.len) |i| {
                                        const it = ins.parameters.items[i];
                                        const cur_annot = annotation.type_list.items[i];

                                        if (cur_annot.getParamType() == .single_type) {
                                            if (it.getType() != cur_annot.asSingleType()) {
                                                self.erroneous_span = it.getSpan();
                                                self.erroneous_expected = cur_annot.asSingleType();
                                                self.erroneous_got = it.getType();

                                                // TODO: add annotation information
                                                return error.ParamsToInstructionAreWrong;
                                            }
                                        } else {
                                            // TODO: check for multiple types
                                        }
                                    }
                                }

                                const res = try map_item.function(&generator, self, ins.parameters.items);

                                switch (res) {
                                    .ok => {},

                                    else => {
                                        self.erroneous_result = res;
                                        return error.InstructionError;
                                    },
                                }
                            } else {
                                self.erroneous_span = ins.name.span;
                                return error.InstructionDoesntExist;
                            }

                            // add the null byte to the end of the function if needed
                            if (self.nul_after_sequence) {
                                try generator.append(self.nul_byte);
                            }
                        }
                    },

                    else => {},
                }
            }

            try self.procedure_map.put(procedure_name, generator.binary);
        }

        pub fn peepholeOptimizeBinary(self: *Self) !void {
            try self.peephole_optimizer.optimizeUsingKnownInstructions(&self.procedure_map);
        }
    };
}

// =====- Tests -===== //

fn movInstructionTest(generator: *Generator(i32), vendor: *Vendor(i32), args: []Value) !InstructionResult {
    _ = vendor;
    try generator.append(5);
    if (args.len == 1) {
        std.debug.print("{any}\n", .{args[0]});
    }
    try std.testing.expectEqual(0, args.len);

    return .ok;
}

fn movInstructionTestError(generator: *Generator(i32), vendor: *Vendor(i32), args: []Value) !InstructionResult {
    _ = vendor;
    _ = args;
    _ = generator;
    return InstructionResult.typeMismatch(.literal, .register);
}

fn oneArgumentInstruction(generator: *Generator(i32), vendor: *Vendor(i32), args: []Value) !InstructionResult {
    _ = vendor;
    _ = generator;

    try std.testing.expectEqual(1, args.len);
    try std.testing.expectEqual(0x0A, args[0].toNumber().getNumber());

    return .ok;
}

fn registerSample(generator: *Generator(i8), vendor: *Vendor(i8), args: []Value) !InstructionResult {
    _ = vendor;
    _ = generator;

    try std.testing.expectEqual(1, args.len);

    return .ok;
}

fn oneArgumentInstructionWithPlacement(generator: *Generator(i32), vendor: *Vendor(i32), args: []Value) InstructionError!void {
    _ = vendor;
    try std.testing.expectEqual(1, args.len);
    try std.testing.expectEqual(0x0A, args[0].toNumber().getNumber());
    try generator.append(25);
}

fn createNodeFrom(alloc: std.mem.Allocator, text: []const u8) !Node {
    var lexer = Lexer.init(alloc);

    lexer.setInputText(text);
    try lexer.startLexingInputText();

    var parser = Parser.init(alloc, &lexer.stream);
    defer parser.deinit();

    return try parser.createRootNode();
}

test "creating and using a vendor with 0 argument function and one statement" {
    var arena = std.heap.ArenaAllocator.init(std.testing.allocator);
    const allocatir = arena.allocator();
    defer arena.deinit();

    var sibc = Vendor(i32).init(allocatir);

    var mov_ins = Instruction(i32).init("mov", &movInstructionTest);
    try sibc.implementInstruction("mov", &mov_ins);

    const root = try createNodeFrom(allocatir, "a: mov");

    try sibc.generateBinary(root);
    try std.testing.expect(sibc.procedure_map.get("a") != null);
    try std.testing.expectEqual(1, sibc.procedure_map.get("a").?.items.len);
}

test "creating and using a vendor with 0 argument function and two statements" {
    var arena = std.heap.ArenaAllocator.init(std.testing.allocator);
    const allocatir = arena.allocator();
    defer arena.deinit();

    var sibc = Vendor(i32).init(allocatir);

    var mov_ins = Instruction(i32).init("mov", &movInstructionTest);
    try sibc.implementInstruction("mov", &mov_ins);

    const root = try createNodeFrom(allocatir, "a: mov\nmov");

    try sibc.generateBinary(root);
    try std.testing.expect(sibc.procedure_map.get("a") != null);
    try std.testing.expectEqual(2, sibc.procedure_map.get("a").?.items.len);
}

test "creating and using a vendor with 0 argument functions, one calling the other for its instructions and folding it" {
    var arena = std.heap.ArenaAllocator.init(std.testing.allocator);
    const allocatir = arena.allocator();
    defer arena.deinit();

    var sibc = Vendor(i32).init(allocatir);

    var mov_ins = Instruction(i32).init("mov", &movInstructionTest);
    try sibc.implementInstruction("mov", &mov_ins);

    const root = try createNodeFrom(allocatir, "a: mov\nmov\n\nb: a\n");

    try sibc.generateBinary(root);
    try std.testing.expect(sibc.procedure_map.get("a") != null);
    try std.testing.expectEqual(2, sibc.procedure_map.get("a").?.items.len);

    try std.testing.expect(sibc.procedure_map.get("b") != null);
    try std.testing.expectEqual(2, sibc.procedure_map.get("b").?.items.len);
}

test "creating and using a vendor with 0 argument functions but multiple subroutines" {
    var arena = std.heap.ArenaAllocator.init(std.testing.allocator);
    const allocatir = arena.allocator();
    defer arena.deinit();

    var sibc = Vendor(i32).init(allocatir);

    var mov_ins = Instruction(i32).init("mov", &movInstructionTest);
    try sibc.implementInstruction("mov", &mov_ins);

    const root = try createNodeFrom(allocatir, "a: mov\nb: a\n");

    try sibc.generateBinary(root);
    try std.testing.expect(sibc.procedure_map.get("a") != null);
    try std.testing.expectEqual(1, sibc.procedure_map.get("a").?.items.len);

    try std.testing.expect(sibc.procedure_map.get("b") != null);
    try std.testing.expectEqual(1, sibc.procedure_map.get("b").?.items.len);
}

test "creating and using a vendor with 1 argument function" {
    var arena = std.heap.ArenaAllocator.init(std.testing.allocator);
    const allocatir = arena.allocator();
    defer arena.deinit();

    var sample_vendor = Vendor(i32).init(allocatir);

    var one_ins = Instruction(i32).init("mov", &oneArgumentInstruction);
    try sample_vendor.implementInstruction("one", &one_ins);

    const root = try createNodeFrom(allocatir, "a: one 0x0A ;; runs the `one` instruction with `0x0A`");

    try sample_vendor.generateBinary(root);
    try std.testing.expect(sample_vendor.procedure_map.get("a") != null);
    try std.testing.expectEqual(0, sample_vendor.procedure_map.get("a").?.items.len);
}

test "dead code elimination" {
    var arena = std.heap.ArenaAllocator.init(std.testing.allocator);
    const allocatir = arena.allocator();
    defer arena.deinit();

    var sample_vendor = Vendor(i32).init(allocatir);

    var one_ins = Instruction(i32).init("one", &oneArgumentInstruction);
    try sample_vendor.implementInstruction("one", &one_ins);

    const root = try createNodeFrom(allocatir, "a: one 0x0A\n b: one 0x0A\n _start: a\n ");

    try sample_vendor.generateBinary(root);

    try sample_vendor.peephole_optimizer.remember("_start");
    try sample_vendor.peepholeOptimizeBinary();

    try std.testing.expect(sample_vendor.procedure_map.get("a") != null);
    try std.testing.expect(sample_vendor.procedure_map.get("_start") != null);
    try std.testing.expectEqual(0, sample_vendor.procedure_map.get("a").?.items.len);
    try std.testing.expect(sample_vendor.procedure_map.get("b") == null); // b exited, but got optimized away
}

test "creating and using a vendor with 0 argument functions that returns an error" {
    var arena = std.heap.ArenaAllocator.init(std.testing.allocator);
    const allocatir = arena.allocator();
    defer arena.deinit();

    var sibc = Vendor(i32).init(allocatir);

    var mov_ins = Instruction(i32).init("mov", &movInstructionTestError);
    try sibc.implementInstruction("mov", &mov_ins);

    const root = try createNodeFrom(allocatir, "a: mov\nb: a\n");

    try std.testing.expectError(error.InstructionError, sibc.generateBinary(root));
    try std.testing.expectEqual(.literal, sibc.erroneous_result.type_mismatch.expected);
    try std.testing.expectEqual(.register, sibc.erroneous_result.type_mismatch.got);
}

test "register too big" {
    var arena = std.heap.ArenaAllocator.init(std.testing.allocator);
    const allocatir = arena.allocator();
    defer arena.deinit();

    var sample_vendor = Vendor(i8).init(allocatir);

    var one_ins = Instruction(i8).init("one", &registerSample);
    try sample_vendor.implementInstruction("one", &one_ins);

    const root = try createNodeFrom(allocatir, "_start: one R15353135");

    try std.testing.expectError(error.RegisterNumberTooLarge, sample_vendor.generateBinary(root));

    try sample_vendor.peephole_optimizer.remember("_start");
    try sample_vendor.peepholeOptimizeBinary();
}

test "types" {
    const t = Type.init(.register);
    try std.testing.expectEqual(ValueTag.register, t.asSingleType());
}

test "annotations" {
    var arena = std.heap.ArenaAllocator.init(std.testing.allocator);
    const allocatir = arena.allocator();
    defer arena.deinit();

    var sample_vendor = Vendor(i8).init(allocatir);

    var one_ins = Instruction(i8).init("one", &registerSample);
    try sample_vendor.implementInstruction("one", &one_ins);

    try sample_vendor.registerAnnotation(
        "one",
        &[_]Type{
            .{
                .single_type = .register,
            },
        },
    );

    const root = try createNodeFrom(allocatir, "_start: one R5");

    try sample_vendor.generateBinary(root);

    try sample_vendor.peephole_optimizer.remember("_start");
    try sample_vendor.peepholeOptimizeBinary();
}
